import Mocha, { describe, it } from 'mocha';
import { Chance } from 'chance';

const chance = new Chance();

/**
 * Describe a "suite" with the given `title` and callback `fn` containing nested suites.
 * @param {string} title Title of the test suite
 * @param {function} fn callback function containing nested suites. A Fuzzy Test Runner Compose function is passed to
 * generate fuzzy test runner for running the actual test
 */
export const fuzzyDescribe = (title: string, fn: DescFunc): Mocha.Suite => {
    return describe(`[Fuzzy] ${title}`, function () {
        return fn.call(this, fuzzyTestRunnerCompose);
    });
};
/**
 * Describe a run-only "suite" with the given `title` and callback `fn` containing nested suites.
 * @param {string} title Title of the test suite
 * @param {function} fn callback function containing nested suites. A Fuzzy Test Runner Compose function is passed to
 * generate fuzzy test runner for running the actual test
 */
fuzzyDescribe.only = (title: string, fn: DescFunc): Mocha.Suite => {
    // eslint-disable-next-line mocha/no-exclusive-tests
    return describe.only(`[Fuzzy] ${title}`, function () {
        return fn.call(this, fuzzyTestRunnerCompose);
    });
};
type Done = (err?: any) => void;
type DescFunc = (this: Mocha.Suite, fuzzy: typeof fuzzyTestRunnerCompose, done?: Done) => void;

/**
 * A higher order function to return an fuzzy test runner. The test runner will run the test function provided with
 * different combinations of arguments. Those arguments are generated by the argument types provided in the higher
 * order function.
 * @param {FuzzyArgDef<any>} fuzzyArgDefs list of arguments definitions of the function to test
 */
export function fuzzyTestRunnerCompose(): (testFn: (done: Done) => any, options?: FuzzyTestRunnerOptions) => any;
export function fuzzyTestRunnerCompose<T>(
    args0: FuzzyArgDef<T>,
): (testFn: (args0: FuzzyArg<T>, done: Done) => any, options?: FuzzyTestRunnerOptions) => any;
export function fuzzyTestRunnerCompose<T0, T1>(
    args0: FuzzyArgDef<T0>,
    args1: FuzzyArgDef<T1>,
): (testFn: (args0: FuzzyArg<T0>, args1: FuzzyArg<T1>, done: Done) => any, options?: FuzzyTestRunnerOptions) => any;
export function fuzzyTestRunnerCompose<T0, T1, T2>(
    args0: FuzzyArgDef<T0>,
    args1: FuzzyArgDef<T1>,
    args2: FuzzyArgDef<T2>,
): (
    testFn: (args0: FuzzyArg<T0>, args1: FuzzyArg<T1>, args2: FuzzyArg<T2>, done: Done) => any,
    options?: FuzzyTestRunnerOptions,
) => any;
export function fuzzyTestRunnerCompose(...fuzzyArgDefs: FuzzyArgDef<any>[]) {
    return (testFn: TestFn, options?: FuzzyTestRunnerOptions): any => {
        // Argument signature is defined left-to-right for readability
        // while in reduce it has to be right-to-left because inner function is defined first
        const initFn = (...args: FuzzyArg<any>[]): any => {
            const message = `(${args.map((arg) => argToString(arg.value)).join(', ')})`;
            if (options?.passDone) {
                // eslint-disable-next-line consistent-return
                return it(message, function (done) {
                    if (options?.invalidArgsOnly) {
                        const hasInvalidArg = args.find((arg) => !arg.valid);
                        if (!hasInvalidArg) {
                            done();
                            return;
                        }
                    }
                    testFn.call(this, ...args, done);
                });
            }
            return it(message, function () {
                if (options?.invalidArgsOnly) {
                    const hasInvalidArg = args.find((arg) => !arg.valid);
                    if (!hasInvalidArg) {
                        return;
                    }
                }
                // eslint-disable-next-line consistent-return
                return testFn.call(this, ...args);
            });
        };
        return fuzzyArgDefs.reverse().reduce((accuTestRunner, fuzzyArgDef) => {
            return fuzzyArgTestFnGenerator(accuTestRunner, fuzzyArgDef);
        }, initFn)();
    };
}
const argToString = (arg: any): string => {
    if (typeof arg === 'function') {
        return arg.toString();
    }
    if (typeof arg === 'string' && arg.length > 16) {
        return `"${arg.substr(0, 16)}..."`;
    }
    if (arg === undefined) {
        return 'undefined';
    }
    return JSON.stringify(arg);
};
enum FuzzyArgType {
    Number,
    String,
    Boolean,
    Object,
    Function,
    Undefined,
    Null,
}

/* eslint-disable no-multi-assign */
fuzzyTestRunnerCompose.Number = FuzzyArgType.Number;
fuzzyTestRunnerCompose.String = fuzzyTestRunnerCompose.Str = FuzzyArgType.String;
fuzzyTestRunnerCompose.Boolean = fuzzyTestRunnerCompose.Bool = FuzzyArgType.Boolean;
fuzzyTestRunnerCompose.Object = fuzzyTestRunnerCompose.Obj = FuzzyArgType.Object;
fuzzyTestRunnerCompose.Function = fuzzyTestRunnerCompose.Func = fuzzyTestRunnerCompose.Fn = FuzzyArgType.Function;
fuzzyTestRunnerCompose.Undefined = FuzzyArgType.Undefined;
fuzzyTestRunnerCompose.Null = FuzzyArgType.Null;
/**
 * Generate a fuzzy argument definition function with list of possible argument types
 * @param argTypes list of possible argument types
 */
fuzzyTestRunnerCompose.either = <T>(...argTypes: FuzzyArgType[]): ((validValue: T) => FuzzyArgDef<T>) => {
    return (validValue: T) => ({
        types: argTypes,
        validValue,
    });
};
/**
 * Generate an optional fuzzy argument definition function with list of possible argument types
 * @param argTypes list of possible argument types
 */
fuzzyTestRunnerCompose.optional = <T>(
    ...argTypes: FuzzyArgType[]
): ((validValue: T | undefined) => FuzzyArgDef<T | undefined>) => {
    return (validValue: T | undefined) => ({
        types: [...argTypes, FuzzyArgType.Undefined],
        validValue,
    });
};

const fuzzyArgDefFnGenerator = <T>(type: FuzzyArgType): FuzzyArgDefFn<T> => {
    return (validValue: T): FuzzyArgDef<T> => ({
        types: [type],
        validValue,
    });
};
const fuzzyNilArgDefFnGenerator = <T>(type: FuzzyArgType, validValue: T): FuzzyArgDefFn<T> => {
    return (): FuzzyArgDef<T> => ({
        types: [type],
        validValue,
    });
};
/**
 * Define a number argument
 * @param {number} validValue a valid argument value to be passed to the test function
 */
fuzzyTestRunnerCompose.NumberArg = fuzzyArgDefFnGenerator<number>(FuzzyArgType.Number);
/**
 * Define a string argument
 * @param {string} validValue a valid argument value to be passed to the test function
 */
fuzzyTestRunnerCompose.StringArg = fuzzyTestRunnerCompose.StrArg = fuzzyTestRunnerCompose.EnumArg = fuzzyArgDefFnGenerator<
    string
>(FuzzyArgType.String);
// TODO fuzzyTestRunnerCompose.EnumArg<E>
/**
 * Define a boolean argument
 * @param {string} validValue a valid argument value to be passed to the test function
 */
fuzzyTestRunnerCompose.BooleanArg = fuzzyTestRunnerCompose.BoolArg = fuzzyArgDefFnGenerator<boolean>(
    FuzzyArgType.Boolean,
);
/**
 * Define an object argument
 * @param validValue a valid argument value to be passed to the test function
 */
fuzzyTestRunnerCompose.ObjectArg = fuzzyTestRunnerCompose.ObjArg = fuzzyArgDefFnGenerator<object | any>(
    FuzzyArgType.Object,
);
/**
 * Define a function argument
 * @param validValue a valid argument value to be passed to the test function
 */
fuzzyTestRunnerCompose.FunctionArg = fuzzyTestRunnerCompose.FuncArg = fuzzyTestRunnerCompose.FnArg = fuzzyArgDefFnGenerator<
    (...args: any[]) => any
>(FuzzyArgType.Function);
/**
 * Define a undefined argument
 */
fuzzyTestRunnerCompose.UndefinedArg = fuzzyNilArgDefFnGenerator<undefined>(FuzzyArgType.Undefined, undefined);
fuzzyTestRunnerCompose.NullArg = fuzzyNilArgDefFnGenerator<null>(FuzzyArgType.Null, null);
/* eslint-enable no-multi-assign */

// Entries of all the primitive fuzzy types and random value generator functions
const fuzzyRandArgEntries: FuzzyArgEntry<any>[] = [
    [FuzzyArgType.Number, () => chance.integer({ max: -1 }), 'negative integer'],
    [FuzzyArgType.Number, () => 0],
    [FuzzyArgType.Number, () => chance.integer({ min: 1 }), 'positive integer'],
    [FuzzyArgType.Number, () => chance.floating({ max: -1 }), 'negative floating'],
    [FuzzyArgType.Number, () => 0.0],
    [FuzzyArgType.Number, () => chance.floating({ min: 1 }), 'positive floating'],
    [FuzzyArgType.String, () => chance.string()],
    [FuzzyArgType.String, () => chance.string({ length: 65536 }), 'long string'],
    [FuzzyArgType.Boolean, () => true],
    [FuzzyArgType.Boolean, () => false],
    [FuzzyArgType.Object, () => ({ key: 'value' })],
    [FuzzyArgType.Function, () => () => true],
    [FuzzyArgType.Undefined, () => undefined],
    [FuzzyArgType.Null, () => null],
];
type FuzzyArgEntry<T> = [argType: FuzzyArgType, randFn: FuzzyArgRandFn<T>, optionDescription?: string];
type FuzzyArgRandFn<T> = () => T;

/**
 * Define an function fuzzy argument definition with a valid value
 * @param validValue a valid argument value to be passed to the test function
 */
type FuzzyArgDefFn<T> = (validValue: T) => FuzzyArgDef<T>;

type FuzzyArgDef<T> = {
    types: FuzzyArgType[];
    validValue: T;
};

type TestFn = (...args: (FuzzyArg<any> | string | Done)[]) => any;

export type FuzzyTestRunnerOptions = {
    /**
     * Run only tests with *at least one* invalid arguments
     */
    invalidArgsOnly?: boolean;
    /**
     * Passes a `done` callback to the test function for asynchronous code. If you enable this options, you **must**
     * call the `done` callback passed to denote the end of test execution or else the test will timeout.
     */
    passDone?: boolean;
};

const fuzzyArgTestFnGenerator = (
    accuTestFn: (...testFnArgs: FuzzyArg<any>[]) => any,
    fuzzyArgDef: FuzzyArgDef<any>,
) => {
    const validArgTypes = fuzzyArgDef.types;
    const isValidArgType = (argType: FuzzyArgType): boolean => validArgTypes.includes(argType);
    return (...prevArgs: any[]) => {
        fuzzyRandArgEntries.forEach(([randArgType, randFn]) => {
            const valid = isValidArgType(randArgType);
            const args = [
                ...prevArgs,
                {
                    type: randArgType,
                    valid,
                    value: valid ? fuzzyArgDef.validValue : randFn(),
                },
            ];
            accuTestFn(...args);
        });
    };
};

type FuzzyArg<T> =
    | {
          type: FuzzyArgType;
          valid: true;
          value: T;
      }
    | {
          type: FuzzyArgType;
          valid: false;
          value: any;
      };
